<!doctype html>
<html>
<head>
<title>Holonomic Drive Robot Test</title>
</head>
<body>
<canvas id="c" width="500" height="500"></canvas>
<canvas id="control" width="50" height="50"></canvas>
<style type="text/css">
canvas { border: 1px solid black; }
</style>
<script>
var canvas = document.getElementById('c');
var c = canvas.getContext('2d');
var control = document.getElementById('control');
var cc = control.getContext('2d');
var width = canvas.width;
var height = canvas.height;
var origin = [0, 0];

var inputKeys = {
    x1: 0,
    y1: 0,
    y2: 0
}

var robot = {
    x: 0,
    y: 0,
    speed: 3
}

var mouse = {
    x: 0,
    y: 0
}

var scalec = 20

function scaleV(vec) {
    var ret = [scalec*vec[0], scalec*vec[1]];
    return ret;
}

function scalev(co, vec) {
    var ret = [co*vec[0], co*vec[1]];
    return ret;
}

function scale(x) {
    return x * scalec
}

var squareRadius = 1;
var scaledSquare = scale(squareRadius);

function add(vec1, vec2) {
    return [vec1[0] + vec2[0], vec1[1] + vec2[1]]
}

function line(start, vec) {
    var end = add(start, vec)
    c.beginPath();
    c.moveTo(start[0], start[1]);
    c.lineTo(end[0], end[1]);
    c.stroke();
    c.closePath();
    circle(c, end, 5)
    // eventually add arrows
    // linear rotation multiplied by each of the triangle vectors
}

function circle(can, start, radius) {
    can.beginPath();
    can.arc(start[0], start[1], radius, 0, Math.PI * 2, true);
    can.stroke()
    can.closePath()
}

function motorDrive(frontLeft, frontRight, backLeft, backRight) {
    var final = add(add(frontLeft, frontRight), add(backLeft, backRight))
    line([robot.x, robot.y], scaleV(final))
    return final;
}

function motorToVec(power) {
    /// length is the speed
    // x + y are same length b/c wheels go in one dir
    //return [power/Math.sqrt(2), Math.abs(power)/Math.sqrt(2)];
    return [0, power]
}

function ccwrotate(vec, heading) {
    var radians = heading * Math.PI / 180;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians);

    var x = vec[0]
    var y = vec[1];

    var y2 = y * cos - x * sin;
    var x2 = y * sin + x * cos;

    return [x2, y2];
}

function crotate(vec, heading) {
    var radians = heading * Math.PI / 180;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians);

    var x = vec[0]
    var y = vec[1];

    var y2 = y * cos + x * sin;
    var x2 = -y * sin + x * cos;

    return [x2, y2];
}

var flscale = 1
var frscale = 1
var blscale = 1
var brscale = 1

function inputToDrive(input) {
    var x1 = input[0]
    var y1 = input[1]
    var x2 = input[2]

    var fl = Math.max(-1, Math.min(1, -y1 - x1 + x2));
    var fr = Math.max(-1, Math.min(1, y1 - x1 + x2));
    var bl = Math.max(-1, Math.min(1, -y1 + x1 + x2));
    var br = Math.max(-1, Math.min(1, y1 + x1 + x2));

    // make diagonal lines for wheels with a circle on either side depending on
    // neg or pos then save that as a vec
    // might have to use rotation transform so that it works for other ones
    //besides forwards
    var flvec = ccwrotate(scalev(flscale, motorToVec(fl)), 225);
    var frvec = ccwrotate(scalev(frscale, motorToVec(fr)), 315);
    var blvec = ccwrotate(scalev(blscale, motorToVec(bl)), 135);
    var brvec = ccwrotate(scalev(brscale, motorToVec(br)), 45);
    //c.clearRect(-canvas.width/2, canvas.height/2, canvas.width, canvas.height);
    //c.clearRect(-100, 100, canvas.width, canvas.height);
    c.save();
    c.setTransform(1,0,0,1,0,0);
    // Will always clear the right space
    c.clearRect(0,0,c.canvas.width,c.canvas.height);
    c.restore();
    line([robot.x - scaledSquare, robot.y + scaledSquare], scaleV(flvec))
    line([robot.x + scaledSquare, robot.y + scaledSquare], scaleV(frvec))
    line([robot.x - scaledSquare, robot.y - scaledSquare], scaleV(blvec))
    line([robot.x + scaledSquare, robot.y - scaledSquare], scaleV(brvec))

    var final = motorDrive(flvec, frvec, blvec, brvec)
    c.beginPath();
    c.arc(robot.x, robot.y, 10, 0, Math.PI * 2, true);
    c.stroke()
    c.closePath()
    var rectangle = new Path2D();
    rectangle.rect(robot.x - scaledSquare, robot.y - scaledSquare,
            2*scaledSquare,
            2*scaledSquare);
    c.stroke(rectangle)

    var newx = robot.x + robot.speed * final[0]
    var newy = robot.y + robot.speed * final[1]

    if ((newx - scaledSquare) > (origin[0] - width/2) &&
            (newx + scaledSquare) < (origin[0] + width/2)) {
        robot.x += robot.speed * final[0]
    }
    if ((newy + scaledSquare) < (origin[1] + height/2) &&
            (newy - scaledSquare) > (origin[1] - height/2)) {
        robot.y += robot.speed * final[1]
    }
}
c.transform(1, 0, 0, -1, width/2, height/2)

function clip(number, min, max) {
  return Math.max(min, Math.min(number, max));
}

function getMouse(evt) {
    var rect = control.getBoundingClientRect();
    mouse.x = Math.round((evt.clientX-rect.left)/(rect.right-rect.left)*control.width)
    mouse.y = Math.round((evt.clientY-rect.top)/(rect.bottom-rect.top)*control.height)
}

//cc.transform(1, 0, 0, -1, 50/2, 50/2)

function distance(start, end) {
    return [end[0] - start[0], -end[1] + start[1]]
}

function scale2(scalar, vec) {
    return [scalar * vec[0], scalar * vec[1]]
}

var moving = false

function controlClickDown(e) {
    moving = true
    control.onmousemove = getMouse
}

function controlClickUp(e) {
    moving = false
    control.onmousemove = null;
}

control.onmousedown = controlClickDown;
control.onmouseup = controlClickUp;

var keyboard = false
var w = false
var a = false
var s = false
var d = false
var j = false
var l = false

document.addEventListener('keydown', function(event) {
    keyboard = true
    if(event.keyCode == 87) {
        // w
        w = true
    }
    if(event.keyCode == 65) {
        // a
        a = true
    }
    if(event.keyCode == 83) {
        // s
        s = true
    }
    if(event.keyCode == 68) {
        // d
        d = true
    }
    if(event.keyCode == 74) {
        // j
        j = true
    }
    if(event.keyCode == 76) {
        // l
        l = true
    }
});

document.addEventListener('keyup', function(event) {
    var dec = .6
    if(event.keyCode == 87) {
        // w
        w = false
        inputKeys.y1 = dec * inputKeys.y1
    }
    if(event.keyCode == 65) {
        // a
        a = false
        inputKeys.x1 = dec * inputKeys.x1
    }
    if(event.keyCode == 83) {
        // s
        s = false
        inputKeys.y1 = dec * inputKeys.y1
    }
    if(event.keyCode == 68) {
        // d
        d = false
        inputKeys.x1 = dec * inputKeys.x1
    }
    if(event.keyCode == 74) {
        // j
        j = false
        inputKeys.x2 = -dec
    }
    if(event.keyCode == 76) {
        // l
        l = false
        inputKeys.x2 = dec
    }
    if (!w && !a && !s && !d && !j && !l) {
        keyboard = false
    }
});

var raf;
var acc = .05

function draw() {
    cc.clearRect(0, 0, control.width, control.height);
    if (keyboard) {
        if (a) {
            inputKeys.x1 -= acc
        } else if (d) {
            inputKeys.x1 += acc
        } 

        if (w) {
            inputKeys.y1 += acc
        } else if (s) {
            inputKeys.y1 -= acc
        }

        if (j) {
            inputKeys.x2 -= acc
        } else if (l) {
            inputKeys.x2 += acc
        }

        inputKeys.x1 = clip(inputKeys.x1, -1, 1)
        inputKeys.y1 = clip(inputKeys.y1, -1, 1)
        inputKeys.x2 = clip(inputKeys.x2, -1, 1)

        //var circles = [scale(20, inputKeys.x1), scale(20, inputKeys.y1)]
        var circles = distance([25,25], [20 * inputKeys.x1, 20 * inputKeys.y1])
        console.log(circles)
        circle(cc, circles, 5);//scaleV(20, circles), 5);
        var input = [inputKeys.x1, inputKeys.y1, inputKeys.x2]
        var rotated = ccwrotate(input, 0)
        inputToDrive([rotated[0], rotated[1], 0])
    } else if (moving) {
        circle(cc, [mouse.x, mouse.y], 5);
        var input = scale2(1/20, distance([25,25], [mouse.x, mouse.y]))
        var rotated = ccwrotate(input, 0)
        inputToDrive([rotated[0], rotated[1], 0])
    } else {
        if (Math.abs(inputKeys.x1) < .1) {
            inputKeys.x1 = 0
        } else if (inputKeys.x1 > 0) {
            inputKeys.x1 -= acc
        } else if (inputKeys.x1 < 0) {
            inputKeys.x1 += acc
        }

        if (Math.abs(inputKeys.y1) < .1) {
            inputKeys.y1 = 0
        } else if (inputKeys.y1 > 0) {
            inputKeys.y1 -= acc
        } else if (inputKeys.y1 < 0) {
            inputKeys.y1 += acc
        }

        inputToDrive([inputKeys.x1, inputKeys.y1, 0]);
        //inputToDrive([0, 0, 0]);
        circle(cc, [25, 25], 5);
    }
    raf = window.requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>
