<!doctype html>
<html>
<head>
<title>Holonomic Drive Robot Test</title>
</head>
<body>
<canvas id="c" width="500" height="500"></canvas>
<canvas id="control" width="50" height="50"></canvas>
<style type="text/css">
canvas { border: 1px solid black; }
</style>
<script>
var canvas = document.getElementById('c');
var c = canvas.getContext('2d');
var control = document.getElementById('control');
var cc = control.getContext('2d');
var width = canvas.width;
var height = canvas.height;
var origin = [0, 0];

var robot = {
    x: 0,
    y: 0,
    speed: 3
}

var mouse = {
    x: 0,
    y: 0
}

var scalec = 20

function scaleV(vec) {
    var ret = [scalec*vec[0], scalec*vec[1]];
    return ret;
}

function scale(x) {
    return x * scalec
}

var squareRadius = 1;
var scaledSquare = scale(squareRadius);

function add(vec1, vec2) {
    return [vec1[0] + vec2[0], vec1[1] + vec2[1]]
}

function line(start, vec) {
    var end = add(start, vec)
    c.beginPath();
    c.moveTo(start[0], start[1]);
    c.lineTo(end[0], end[1]);
    c.stroke();
    c.closePath();
    circle(c, end, 5)
    // eventually add arrows
    // linear rotation multiplied by each of the triangle vectors
}

function circle(can, start, radius) {
    can.beginPath();
    can.arc(start[0], start[1], radius, 0, Math.PI * 2, true);
    can.stroke()
    can.closePath()
}

function motorDrive(frontLeft, frontRight, backLeft, backRight) {
    var final = add(add(frontLeft, frontRight), add(backLeft, backRight))
    line([robot.x, robot.y], scaleV(final))
    return final;
}

function motorToVec(power) {
    /// length is the speed
    // x + y are same length b/c wheels go in one dir
    //return [power/Math.sqrt(2), Math.abs(power)/Math.sqrt(2)];
    return [0, power]
}

function ccwrotate(vec, heading) {
    var radians = heading * Math.PI / 180;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians);

    var x = vec[0]
    var y = vec[1];

    var y2 = y * cos - x * sin;
    var x2 = y * sin + x * cos;

    return [x2, y2];
}

function crotate(vec, heading) {
    var radians = heading * Math.PI / 180;
    var cos = Math.cos(radians);
    var sin = Math.sin(radians);

    var x = vec[0]
    var y = vec[1];

    var y2 = y * cos + x * sin;
    var x2 = -y * sin + x * cos;

    return [x2, y2];
}

function inputToDrive(input) {
    var x1 = input[0]
    var y1 = input[1]
    var x2 = input[2]

    var fl = Math.max(-1, Math.min(1, -y1 - x1 + x2));
    var fr = Math.max(-1, Math.min(1, y1 - x1 + x2));
    var bl = Math.max(-1, Math.min(1, -y1 + x1 + x2));
    var br = Math.max(-1, Math.min(1, y1 + x1 + x2));

    // make diagonal lines for wheels with a circle on either side depending on
    // neg or pos then save that as a vec
    // might have to use rotation transform so that it works for other ones
    //besides forwards
    var flvec = ccwrotate(motorToVec(fl), 225);
    var frvec = ccwrotate(motorToVec(fr), 315);
    var blvec = ccwrotate(motorToVec(bl), 135);
    var brvec = ccwrotate(motorToVec(br), 45);
    //c.clearRect(-canvas.width/2, canvas.height/2, canvas.width, canvas.height);
    //c.clearRect(-100, 100, canvas.width, canvas.height);
    c.save();
    c.setTransform(1,0,0,1,0,0);
    // Will always clear the right space
    c.clearRect(0,0,c.canvas.width,c.canvas.height);
    c.restore();
    line([robot.x - scaledSquare, robot.y + scaledSquare], scaleV(flvec))
    line([robot.x + scaledSquare, robot.y + scaledSquare], scaleV(frvec))
    line([robot.x - scaledSquare, robot.y - scaledSquare], scaleV(blvec))
    line([robot.x + scaledSquare, robot.y - scaledSquare], scaleV(brvec))

    var final = motorDrive(flvec, frvec, blvec, brvec)
    c.beginPath();
    c.arc(robot.x, robot.y, 10, 0, Math.PI * 2, true);
    c.stroke()
    c.closePath()
    var rectangle = new Path2D();
    rectangle.rect(robot.x - scaledSquare, robot.y - scaledSquare,
            2*scaledSquare,
            2*scaledSquare);
    c.stroke(rectangle)

    var newx = robot.x + robot.speed * final[0]
    var newy = robot.y + robot.speed * final[1]

    console.log(origin[0] - width/2)
    if ((newx - scaledSquare) > (origin[0] - width/2) &&
            (newx + scaledSquare) < (origin[0] + width/2)) {
        robot.x += robot.speed * final[0]
    }
    if ((newy + scaledSquare) < (origin[1] + height/2) &&
            (newy - scaledSquare) > (origin[1] - height/2)) {
        robot.y += robot.speed * final[1]
    }
}
c.transform(1, 0, 0, -1, width/2, height/2)


function getMouse(evt) {
    var rect = control.getBoundingClientRect();
    mouse.x = Math.round((evt.clientX-rect.left)/(rect.right-rect.left)*control.width)
    mouse.y = Math.round((evt.clientY-rect.top)/(rect.bottom-rect.top)*control.height)
}

//cc.transform(1, 0, 0, -1, 50/2, 50/2)

function distance(start, end) {
    return [end[0] - start[0], -end[1] + start[1]]
}

function scale2(scalar, vec) {
    return [scalar * vec[0], scalar * vec[1]]
}

var moving = false

function controlClickDown(e) {
    moving = true
    control.onmousemove = getMouse
}

function controlClickUp(e) {
    moving = false
    control.onmousemove = null;
}

control.onmousedown = controlClickDown;
control.onmouseup = controlClickUp;

var raf;

function draw() {
    cc.clearRect(0, 0, control.width, control.height);
    if (moving) {
        circle(cc, [mouse.x, mouse.y], 5);
        var input = scale2(1/20, distance([25,25], [mouse.x, mouse.y]))
        var rotated = ccwrotate(input, 0)
        inputToDrive([rotated[0], rotated[1], 0])
    } else {
        inputToDrive([0, 0, 0]);
        circle(cc, [25, 25], 5);
    }
    raf = window.requestAnimationFrame(draw);
}

draw();
</script>
</body>
</html>

